name: Pull Request Tests

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]
    branches: [ main, develop ]

# Cancel in-progress runs for the same PR
concurrency:
  group: ${{ github.workflow }}-${{ github.event.workflow_run.head_branch }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    # Only run if CI/CD workflow succeeded and was triggered by a pull request
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event == 'pull_request'
    outputs:
      go: ${{ steps.changes.outputs.go }}
      docker: ${{ steps.changes.outputs.docker }}
      k8s: ${{ steps.changes.outputs.k8s }}
      docs: ${{ steps.changes.outputs.docs }}
      pr_number: ${{ steps.get_pr.outputs.pr_number }}
    steps:
    - name: Get PR number
      id: get_pr
      run: |
        PR_NUMBER=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/repos/${{ github.repository }}/pulls?head=${{ github.event.workflow_run.head_sha }}" \
          | jq -r '.[0].number')
        echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
        
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # Check out the head commit of the PR that triggered the workflow_run
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Detect changes
      uses: dorny/paths-filter@v2
      id: changes
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        filters: |
          go:
            - '**/*.go'
            - 'go.mod'
            - 'go.sum'
          docker:
            - 'Dockerfile'
            - '.dockerignore'
          k8s:
            - 'deploy/**/*.yaml'
            - 'deploy/**/*.yml'
          docs:
            - '**/*.md'
            - 'docs/**/*'

  lint:
    name: Lint Code
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.go == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-lint-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-lint-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-lint-
          
    - name: Set up Go module permissions
      run: |
        # Ensure proper permissions for Go modules
        if [ -d ~/go/pkg/mod ]; then
          chmod -R u+w ~/go/pkg/mod || true
        fi
        
    - name: golangci-lint
      uses: golangci/golangci-lint-action@v8
      with:
        version: latest
        args: --timeout=5m
        
    - name: Go fmt check
      run: |
        if [ "$(gofmt -s -l . | wc -l)" -gt 0 ]; then
          echo "The following files are not formatted:"
          gofmt -s -l .
          exit 1
        fi
        
    - name: Go vet
      run: go vet ./...
      
    - name: Check for inefficient assignments
      run: |
        go install github.com/gordonklaus/ineffassign@latest
        ineffassign ./...

  test:
    name: Test Suite
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.go == 'true'
    
    strategy:
      matrix:
        go-version: ['1.21', '1.22', '1.23', '1.24']
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Set up Go ${{ matrix.go-version }}
      uses: actions/setup-go@v5
      with:
        go-version: ${{ matrix.go-version }}
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-${{ matrix.go-version }}-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-${{ matrix.go-version }}-
          
    - name: Set up Go module permissions
      run: |
        # Ensure proper permissions for Go modules
        if [ -d ~/go/pkg/mod ]; then
          chmod -R u+w ~/go/pkg/mod || true
        fi
          
    - name: Download dependencies
      run: |
        go mod download
        go mod verify
      
    - name: Run tests with race detection
      run: go test -v -race -coverprofile=coverage.out ./...
      
    - name: Upload coverage
      uses: codecov/codecov-action@v5
      with:
        flags: unittests
        name: go-${{ matrix.go-version }}
        slug: rl-io/coredns-ingress-sync
        token: ${{ secrets.CODECOV_TOKEN }}
        fail_ci_if_error: false

  docker-build:
    name: Docker Build Test
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.docker == 'true' || needs.changes.outputs.go == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build Docker image
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: false
        tags: coredns-ingress-sync:pr-${{ needs.changes.outputs.pr_number }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/image.tar
        
    - name: Load image for testing
      run: |
        docker load -i /tmp/image.tar
        docker tag coredns-ingress-sync:pr-${{ needs.changes.outputs.pr_number }} coredns-ingress-sync:test
        
    - name: Test Docker image
      run: |
        # Test that the image runs (will fail due to no k8s, but should start)
        timeout 10s docker run --rm coredns-ingress-sync:test || true
        
    - name: Scan Docker image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: 'coredns-ingress-sync:test'
        format: 'table'
        exit-code: '1'
        severity: 'CRITICAL,HIGH'

  integration-test:
    name: Integration Tests
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.go == 'true' || needs.changes.outputs.k8s == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.24'
        
    - name: Cache Go modules
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/go-build
          ~/go/pkg/mod
        key: ${{ runner.os }}-go-integration-${{ hashFiles('**/go.sum') }}-${{ hashFiles('**/go.mod') }}
        restore-keys: |
          ${{ runner.os }}-go-integration-${{ hashFiles('**/go.sum') }}-
          ${{ runner.os }}-go-integration-
          
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Set up Kind cluster
      uses: helm/kind-action@v1.12.0
      with:
        cluster_name: pr-test-cluster
        
    - name: Build and load image
      uses: docker/build-push-action@v6
      with:
        context: .
        platforms: linux/amd64
        push: false
        tags: coredns-ingress-sync:pr-test
        cache-from: type=gha
        cache-to: type=gha,mode=max
        outputs: type=docker,dest=/tmp/pr-test-image.tar
        
    - name: Load image to Kind cluster
      run: |
        docker load -i /tmp/pr-test-image.tar
        kind load docker-image coredns-ingress-sync:pr-test --name pr-test-cluster
        
    - name: Run integration tests
      run: |
        chmod +x tests/run_tests.sh
        ./tests/run_tests.sh --integration
        
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: integration-test-results-${{ needs.changes.outputs.pr_number }}
        path: test_results/

  docs-check:
    name: Documentation Check
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.docs == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        ref: ${{ github.event.workflow_run.head_sha }}
      
    - name: Lint Markdown
      uses: DavidAnson/markdownlint-cli2-action@v20
      with:
        globs: '**/*.md'
        
    - name: Check links
      uses: gaurav-nelson/github-action-markdown-link-check@v1
      with:
        use-quiet-mode: 'yes'
        use-verbose-mode: 'yes'
        
    - name: Spell check
      uses: crate-ci/typos@master

  pr-comment:
    name: PR Status Comment
    runs-on: ubuntu-latest
    needs: [changes, lint, test, docker-build, integration-test]
    if: always() && github.event.workflow_run.event == 'pull_request'
    
    steps:
    - name: Create PR comment
      uses: actions/github-script@v7
      with:
        script: |
          const prNumber = '${{ needs.changes.outputs.pr_number }}';
          
          if (!prNumber || prNumber === 'null') {
            console.log('No PR number found, skipping comment');
            return;
          }
          
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: prNumber,
          });
          
          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && comment.body.includes('## 🧪 Test Results')
          );
          
          const lintResult = '${{ needs.lint.result }}';
          const testResult = '${{ needs.test.result }}';
          const dockerResult = '${{ needs.docker-build.result }}';
          const integrationResult = '${{ needs.integration-test.result }}';
          
          const resultEmoji = (result) => {
            switch(result) {
              case 'success': return '✅';
              case 'failure': return '❌';
              case 'cancelled': return '⏹️';
              case 'skipped': return '⏭️';
              default: return '❔';
            }
          };
          
          const commentBody = `## 🧪 Test Results
          
          | Check | Status |
          |-------|--------|
          | Lint | ${resultEmoji(lintResult)} ${lintResult} |
          | Tests | ${resultEmoji(testResult)} ${testResult} |
          | Docker Build | ${resultEmoji(dockerResult)} ${dockerResult} |
          | Integration Tests | ${resultEmoji(integrationResult)} ${integrationResult} |
          
          ${lintResult === 'failure' || testResult === 'failure' || dockerResult === 'failure' || integrationResult === 'failure' ? 
            '❌ Some checks failed. Please review the logs and fix the issues.' : 
            '✅ All checks passed! This PR is ready for review.'}
          
          ---
          *Updated at: ${new Date().toISOString()}*`;
          
          if (botComment) {
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody
            });
          } else {
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: commentBody
            });
          }
