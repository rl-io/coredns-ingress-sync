
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>preflight: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/rl-io/coredns-ingress-sync/internal/preflight/checker.go (83.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package preflight

import (
        "context"
        "fmt"
        "strings"
        "time"

        "github.com/go-logr/logr"
        appsv1 "k8s.io/api/apps/v1"
        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"

        "github.com/rl-io/coredns-ingress-sync/internal/config"
)

// Config holds the preflight check configuration
type Config struct {
        DeploymentName       string
        ReleaseInstance      string
        MountPath            string
        VolumeName           string
        DynamicConfigMapName string
        CoreDNSNamespace     string
        IngressClass         string
        TargetCNAME          string
}

// Checker performs preflight checks for deployment conflicts
type Checker struct {
        client client.Client
        config Config
        logger logr.Logger
}

// NewChecker creates a new preflight checker
func NewChecker(client client.Client, config Config, logger logr.Logger) *Checker <span class="cov8" title="1">{
        return &amp;Checker{
                client: client,
                config: config,
                logger: logger,
        }
}</span>

// CheckResult represents the result of a preflight check
type CheckResult struct {
        Passed   bool
        Warning  bool
        Message  string
        Severity string // "error", "warning", "info"
}

// RunChecks performs all preflight checks and returns results
func (c *Checker) RunChecks(ctx context.Context) ([]CheckResult, error) <span class="cov8" title="1">{
        var results []CheckResult
        start := time.Now()

        c.logger.Info("üîç Running preflight checks for CoreDNS ingress sync deployment",
                "deployment", c.config.DeploymentName,
                "mountPath", c.config.MountPath,
                "volumeName", c.config.VolumeName)

        // Check 1: CoreDNS deployment exists (with retry for RBAC issues)
        checkStart := time.Now()
        result, err := c.checkCoreDNSDeploymentWithRetry(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check CoreDNS deployment after %v: %w", time.Since(checkStart), err)
        }</span>
        <span class="cov8" title="1">c.logger.Info("‚úì CoreDNS deployment check completed", "duration", time.Since(checkStart), "passed", result.Passed)
        results = append(results, result)
        if !result.Passed </span><span class="cov8" title="1">{
                c.logger.Info("üèÉ Early exit due to CoreDNS deployment check failure", "totalDuration", time.Since(start))
                return results, nil // Early exit if CoreDNS doesn't exist
        }</span>

        // Check 2: Mount path conflicts
        <span class="cov8" title="1">checkStart = time.Now()
        result, err = c.checkMountPathConflicts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check mount path conflicts after %v: %w", time.Since(checkStart), err)
        }</span>
        <span class="cov8" title="1">c.logger.Info("‚úì Mount path check completed", "duration", time.Since(checkStart), "passed", result.Passed)
        results = append(results, result)

        // Check 3: ConfigMap conflicts
        checkStart = time.Now()
        result, err = c.checkConfigMapConflicts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check ConfigMap conflicts after %v: %w", time.Since(checkStart), err)
        }</span>
        <span class="cov8" title="1">c.logger.Info("‚úì ConfigMap check completed", "duration", time.Since(checkStart), "passed", result.Passed)
        results = append(results, result)

        // Check 4: Duplicate controllers
        checkStart = time.Now()
        result, err = c.checkDuplicateControllers(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check duplicate controllers after %v: %w", time.Since(checkStart), err)
        }</span>
        <span class="cov8" title="1">c.logger.Info("‚úì Duplicate controllers check completed", "duration", time.Since(checkStart), "passed", result.Passed)
        results = append(results, result)

        c.logger.Info("üéâ All preflight checks completed", "totalDuration", time.Since(start))
        return results, nil</span>
}

// checkCoreDNSDeployment verifies CoreDNS deployment exists
func (c *Checker) checkCoreDNSDeployment(ctx context.Context) (CheckResult, error) <span class="cov8" title="1">{
        deployment := &amp;appsv1.Deployment{}
        err := c.client.Get(ctx, types.NamespacedName{
                Name:      "coredns",
                Namespace: c.config.CoreDNSNamespace,
        }, deployment)

        if err != nil </span><span class="cov8" title="1">{
                // Check if this is a permission/RBAC error
                if errors.IsForbidden(err) </span><span class="cov0" title="0">{
                        return CheckResult{
                                Passed:   false,
                                Message:  fmt.Sprintf("‚ùå Permission denied accessing CoreDNS deployment in namespace %s. This usually means RBAC resources are not yet created. Try again in a few seconds.", c.config.CoreDNSNamespace),
                                Severity: "error",
                        }, nil
                }</span>
                
                <span class="cov8" title="1">if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        return CheckResult{
                                Passed:   false,
                                Message:  fmt.Sprintf("‚ùå CoreDNS deployment not found in namespace %s", c.config.CoreDNSNamespace),
                                Severity: "error",
                        }, nil
                }</span>
                
                // Other errors
                <span class="cov0" title="0">return CheckResult{
                        Passed:   false,
                        Message:  fmt.Sprintf("‚ùå Error accessing CoreDNS deployment: %v", err),
                        Severity: "error",
                }, nil</span>
        }

        <span class="cov8" title="1">return CheckResult{
                Passed:   true,
                Message:  "‚úÖ CoreDNS deployment found",
                Severity: "info",
        }, nil</span>
}

// checkCoreDNSDeploymentWithRetry performs the CoreDNS deployment check with retry for RBAC propagation
func (c *Checker) checkCoreDNSDeploymentWithRetry(ctx context.Context) (CheckResult, error) <span class="cov8" title="1">{
        const maxRetries = 2  // Reduced from 3 for faster failure
        const retryDelay = 1 * time.Second  // Reduced from 2 seconds
        
        for attempt := 1; attempt &lt;= maxRetries; attempt++ </span><span class="cov8" title="1">{
                attemptStart := time.Now()
                c.logger.Info("Attempting CoreDNS deployment check", "attempt", attempt, "maxRetries", maxRetries)
                
                result, err := c.checkCoreDNSDeployment(ctx)
                duration := time.Since(attemptStart)
                
                // If no error or not a permission error, return immediately
                if err != nil || result.Passed || !strings.Contains(result.Message, "Permission denied") </span><span class="cov8" title="1">{
                        c.logger.Info("CoreDNS deployment check completed", 
                                "attempt", attempt, 
                                "duration", duration, 
                                "passed", result.Passed, 
                                "error", err != nil)
                        return result, err
                }</span>
                
                // If it's a permission error and we have retries left, wait and retry
                <span class="cov0" title="0">if attempt &lt; maxRetries </span><span class="cov0" title="0">{
                        c.logger.Info("RBAC permissions not ready, retrying...", 
                                "attempt", attempt, 
                                "maxRetries", maxRetries,
                                "duration", duration,
                                "retryDelay", retryDelay)
                        time.Sleep(retryDelay)
                        continue</span>
                }
                
                // Final attempt failed
                <span class="cov0" title="0">c.logger.Info("All retry attempts exhausted", "totalAttempts", maxRetries, "finalDuration", duration)
                return result, err</span>
        }
        
        // Should never reach here, but satisfy compiler
        <span class="cov0" title="0">return CheckResult{Passed: false, Message: "Unexpected error in retry logic", Severity: "error"}, nil</span>
}

// checkMountPathConflicts checks for mount path conflicts
func (c *Checker) checkMountPathConflicts(ctx context.Context) (CheckResult, error) <span class="cov8" title="1">{
        deployment := &amp;appsv1.Deployment{}
        err := c.client.Get(ctx, types.NamespacedName{
                Name:      "coredns",
                Namespace: c.config.CoreDNSNamespace,
        }, deployment)

        if err != nil </span><span class="cov0" title="0">{
                // Check if this is a permission/RBAC error
                if errors.IsForbidden(err) </span><span class="cov0" title="0">{
                        return CheckResult{
                                Passed:   false,
                                Message:  "‚ùå Permission denied accessing CoreDNS deployment for mount path check. RBAC resources may not be ready yet.",
                                Severity: "error",
                        }, nil
                }</span>
                
                <span class="cov0" title="0">return CheckResult{
                        Passed:   false,
                        Message:  fmt.Sprintf("‚ùå Could not retrieve CoreDNS deployment for mount path check: %v", err),
                        Severity: "error",
                }, nil</span>
        }

        <span class="cov8" title="1">if len(deployment.Spec.Template.Spec.Containers) == 0 </span><span class="cov8" title="1">{
                return CheckResult{
                        Passed:   false,
                        Message:  "‚ùå CoreDNS deployment has no containers",
                        Severity: "error",
                }, nil
        }</span>

        <span class="cov8" title="1">container := deployment.Spec.Template.Spec.Containers[0]
        for _, mount := range container.VolumeMounts </span><span class="cov8" title="1">{
                if mount.MountPath == c.config.MountPath &amp;&amp; mount.Name != c.config.VolumeName </span><span class="cov8" title="1">{
                        return CheckResult{
                                Passed:  false,
                                Message: fmt.Sprintf("‚ùå Mount path conflict detected!\n   Path: %s\n   Existing volume: %s\n   Our volume: %s\n\nüí° Suggested solutions:\n   1. Set a custom mount path in Helm values\n   2. Use a different deployment name\n   3. Remove the conflicting mount from CoreDNS", c.config.MountPath, mount.Name, c.config.VolumeName),
                                Severity: "error",
                        }, nil
                }</span>
        }

        <span class="cov8" title="1">return CheckResult{
                Passed:   true,
                Message:  "‚úÖ No mount path conflicts detected",
                Severity: "info",
        }, nil</span>
}

// checkConfigMapConflicts checks for ConfigMap conflicts
func (c *Checker) checkConfigMapConflicts(ctx context.Context) (CheckResult, error) <span class="cov8" title="1">{
        configMap := &amp;corev1.ConfigMap{}
        err := c.client.Get(ctx, types.NamespacedName{
                Name:      c.config.DynamicConfigMapName,
                Namespace: c.config.CoreDNSNamespace,
        }, configMap)

        if err != nil </span><span class="cov8" title="1">{
                // ConfigMap doesn't exist, no conflict
                return CheckResult{
                        Passed:   true,
                        Message:  "‚úÖ No ConfigMap conflicts detected",
                        Severity: "info",
                }, nil
        }</span>

        // Check if managed by a different instance
        <span class="cov8" title="1">managedBy := ""
        if configMap.Labels != nil </span><span class="cov8" title="1">{
                managedBy = configMap.Labels["app.kubernetes.io/instance"]
        }</span>

        <span class="cov8" title="1">if managedBy != "" &amp;&amp; managedBy != c.config.ReleaseInstance </span><span class="cov8" title="1">{
                return CheckResult{
                        Passed:  false,
                        Message: fmt.Sprintf("‚ùå ConfigMap conflict detected!\n   ConfigMap: %s\n   Managed by instance: %s\n   Our instance: %s\n\nüí° Suggested solutions:\n   1. Set a custom ConfigMap name in Helm values\n   2. Use a different release name", c.config.DynamicConfigMapName, managedBy, c.config.ReleaseInstance),
                        Severity: "error",
                }, nil
        }</span>

        <span class="cov8" title="1">return CheckResult{
                Passed:   true,
                Message:  "‚úÖ No ConfigMap conflicts detected",
                Severity: "info",
        }, nil</span>
}

// checkDuplicateControllers checks for other similar controllers
func (c *Checker) checkDuplicateControllers(ctx context.Context) (CheckResult, error) <span class="cov8" title="1">{
        deploymentList := &amp;appsv1.DeploymentList{}
        err := c.client.List(ctx, deploymentList, client.MatchingLabels{
                "app.kubernetes.io/name": "coredns-ingress-sync",
        })

        if err != nil </span><span class="cov0" title="0">{
                return CheckResult{
                        Passed:   true,
                        Warning:  true,
                        Message:  "‚ö†Ô∏è  Could not check for duplicate controllers (non-critical)",
                        Severity: "warning",
                }, nil
        }</span>

        <span class="cov8" title="1">var otherDeployments []string
        for _, deployment := range deploymentList.Items </span><span class="cov8" title="1">{
                if deployment.Name != c.config.DeploymentName </span><span class="cov8" title="1">{
                        otherDeployments = append(otherDeployments, fmt.Sprintf("%s/%s", deployment.Namespace, deployment.Name))
                }</span>
        }

        <span class="cov8" title="1">if len(otherDeployments) &gt; 0 </span><span class="cov8" title="1">{
                message := "‚ö†Ô∏è  Found other coredns-ingress-sync deployments:\n"
                for _, dep := range otherDeployments </span><span class="cov8" title="1">{
                        message += fmt.Sprintf("   - %s\n", dep)
                }</span>
                <span class="cov8" title="1">message += "\nüí° Make sure each deployment watches different:\n"
                message += "   - Ingress classes\n"
                message += "   - Namespaces\n"
                message += "   - Or targets different CNAMEs"

                return CheckResult{
                        Passed:   true,
                        Warning:  true,
                        Message:  message,
                        Severity: "warning",
                }, nil</span>
        }

        <span class="cov8" title="1">return CheckResult{
                Passed:   true,
                Message:  "‚úÖ No duplicate controllers detected",
                Severity: "info",
        }, nil</span>
}

// PrintResults prints the check results in a formatted way
func (c *Checker) PrintResults(results []CheckResult) <span class="cov8" title="1">{
        c.logger.Info("")
        c.logger.Info("üìã Preflight Check Results:")
        c.logger.Info("============================")

        passed := 0
        warnings := 0
        errors := 0

        for _, result := range results </span><span class="cov8" title="1">{
                // Split message into lines for better formatting
                lines := strings.Split(result.Message, "\n")
                for i, line := range lines </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                c.logger.Info(line)
                        }</span> else<span class="cov0" title="0"> if strings.TrimSpace(line) != "" </span><span class="cov0" title="0">{
                                c.logger.Info("   " + line)
                        }</span>
                }

                <span class="cov8" title="1">switch result.Severity </span>{
                case "error":<span class="cov8" title="1">
                        if !result.Passed </span><span class="cov8" title="1">{
                                errors++
                        }</span>
                case "warning":<span class="cov0" title="0">
                        warnings++</span>
                case "info":<span class="cov8" title="1">
                        if result.Passed </span><span class="cov8" title="1">{
                                passed++
                        }</span>
                }
        }

        <span class="cov8" title="1">c.logger.Info("")
        c.logger.Info("üìä Summary:")
        c.logger.Info(fmt.Sprintf("   ‚úÖ Passed: %d", passed))
        if warnings &gt; 0 </span><span class="cov0" title="0">{
                c.logger.Info(fmt.Sprintf("   ‚ö†Ô∏è  Warnings: %d", warnings))
        }</span>
        <span class="cov8" title="1">if errors &gt; 0 </span><span class="cov8" title="1">{
                c.logger.Info(fmt.Sprintf("   ‚ùå Errors: %d", errors))
        }</span>

        <span class="cov8" title="1">if errors == 0 </span><span class="cov0" title="0">{
                c.logger.Info("")
                c.logger.Info("üéâ All critical checks passed! Deployment can proceed safely.")
        }</span> else<span class="cov8" title="1"> {
                c.logger.Info("")
                c.logger.Info("‚ùå PREFLIGHT CHECKS FAILED - Deployment cannot proceed")
                c.logger.Info("Please resolve the above errors before installing/upgrading.")
        }</span>
}

// HasErrors returns true if any check failed with an error
func HasErrors(results []CheckResult) bool <span class="cov8" title="1">{
        for _, result := range results </span><span class="cov8" title="1">{
                if !result.Passed &amp;&amp; result.Severity == "error" </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// ConfigFromEnv creates a preflight config from the current environment
func ConfigFromEnv(cfg *config.Config) Config <span class="cov8" title="1">{
        return Config{
                DeploymentName:       cfg.ControllerNamespace, // This will be set by Helm
                ReleaseInstance:      cfg.ControllerNamespace, // This will be set by Helm  
                MountPath:            cfg.MountPath,
                VolumeName:           cfg.CoreDNSVolumeName,
                DynamicConfigMapName: cfg.DynamicConfigMapName,
                CoreDNSNamespace:     cfg.CoreDNSNamespace,
                IngressClass:         cfg.IngressClass,
                TargetCNAME:          cfg.TargetCNAME,
        }
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
