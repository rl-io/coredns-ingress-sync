package coredns

import (
	"context"
	"fmt"
	"log"
	"os"
	"strings"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/kubernetes"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

// Config holds CoreDNS configuration
type Config struct {
	Namespace           string
	ConfigMapName       string
	DynamicConfigMapName string
	DynamicConfigKey    string
	ImportStatement     string
	TargetCNAME         string
}

// Manager handles CoreDNS configuration management
type Manager struct {
	client client.Client
	config Config
}

// DeploymentClient interface for Kubernetes deployment operations
type DeploymentClient interface {
	UpdateDeployment(ctx context.Context, deployment *appsv1.Deployment) error
	GetDeployment(ctx context.Context, name, namespace string) (*appsv1.Deployment, error)
}

// KubernetesClient wraps the Kubernetes clientset
type KubernetesClient struct {
	clientset kubernetes.Interface
}

// ControllerRuntimeClient wraps the controller-runtime client for testing
type ControllerRuntimeClient struct {
	client client.Client
}

// NewManager creates a new CoreDNS manager
func NewManager(client client.Client, config Config) *Manager {
	return &Manager{
		client: client,
		config: config,
	}
}

// UpdateDynamicConfigMap creates or updates the dynamic configuration ConfigMap
func (m *Manager) UpdateDynamicConfigMap(ctx context.Context, domains []string, hosts []string) error {
	configMapName := types.NamespacedName{
		Name:      m.config.DynamicConfigMapName,
		Namespace: m.config.Namespace,
	}

	// Generate dynamic configuration
	dynamicConfig := m.generateDynamicConfig(domains, hosts)

	// Retry logic to handle concurrent updates
	for attempt := 0; attempt < 3; attempt++ {
		// Get or create the dynamic ConfigMap (fresh read each attempt)
		configMap := &corev1.ConfigMap{}
		err := m.client.Get(ctx, configMapName, configMap)

		if err != nil {
			// Create new ConfigMap if it doesn't exist
			configMap = &corev1.ConfigMap{
				ObjectMeta: metav1.ObjectMeta{
					Name:      m.config.DynamicConfigMapName,
					Namespace: m.config.Namespace,
					Labels: map[string]string{
						"app.kubernetes.io/managed-by": "coredns-ingress-sync",
					},
				},
				Data: make(map[string]string),
			}

			// Set the content and try to create
			configMap.Data[m.config.DynamicConfigKey] = dynamicConfig

			if err := m.client.Create(ctx, configMap); err != nil {
				if attempt == 2 {
					return fmt.Errorf("failed to create dynamic ConfigMap after retries: %w", err)
				}
				continue // Retry
			}
			log.Printf("Created dynamic ConfigMap %s with %d domains", m.config.DynamicConfigMapName, len(domains))
			return nil
		}

		// Check if content has actually changed to avoid unnecessary updates
		if existingConfig, exists := configMap.Data[m.config.DynamicConfigKey]; exists && existingConfig == dynamicConfig {
			log.Printf("Dynamic ConfigMap %s is already up to date", m.config.DynamicConfigMapName)
			return nil
		}

		// Update ConfigMap with fresh data
		configMap.Data[m.config.DynamicConfigKey] = dynamicConfig

		// Ensure labels are set for identification
		if configMap.Labels == nil {
			configMap.Labels = make(map[string]string)
		}
		configMap.Labels["app.kubernetes.io/managed-by"] = "coredns-ingress-sync"

		// Try to update
		if err := m.client.Update(ctx, configMap); err != nil {
			if attempt == 2 {
				return fmt.Errorf("failed to update dynamic ConfigMap after retries: %w", err)
			}
			// Brief delay before retry to reduce contention
			time.Sleep(time.Millisecond * 100)
			continue // Retry with fresh read
		}

		log.Printf("Updated dynamic ConfigMap %s with %d domains", m.config.DynamicConfigMapName, len(domains))
		return nil
	}

	return fmt.Errorf("exhausted retries updating dynamic ConfigMap")
}

// generateDynamicConfig creates the CoreDNS configuration content
func (m *Manager) generateDynamicConfig(domains []string, hosts []string) string {
	var config strings.Builder

	// Header
	config.WriteString("# Auto-generated by coredns-ingress-sync controller\n")
	config.WriteString(fmt.Sprintf("# Last updated: %s\n", time.Now().Format(time.RFC3339)))
	config.WriteString("\n")

	// Generate individual rewrite rules for each discovered host
	for _, host := range hosts {
		config.WriteString(fmt.Sprintf("rewrite name exact %s %s\n", host, m.config.TargetCNAME))
	}

	return config.String()
}

// EnsureConfiguration ensures CoreDNS is properly configured
func (m *Manager) EnsureConfiguration(ctx context.Context) error {
	// Check if we should manage CoreDNS configuration
	if os.Getenv("COREDNS_AUTO_CONFIGURE") == "false" {
		log.Printf("CoreDNS auto-configuration disabled")
		return nil
	}

	// First, ensure the import statement is in the CoreDNS Corefile
	if err := m.ensureImport(ctx); err != nil {
		// Log the error but don't fail the reconciliation if CoreDNS is not available
		log.Printf("Warning: Failed to ensure CoreDNS import statement: %v", err)
		return nil
	}

	// Then, ensure the CoreDNS deployment has the volume mount
	if err := m.ensureVolumeMount(ctx); err != nil {
		// Log the error but don't fail the reconciliation if CoreDNS is not available
		log.Printf("Warning: Failed to ensure CoreDNS volume mount: %v", err)
		return nil
	}

	return nil
}

// ensureImport ensures the import statement is in the CoreDNS Corefile
func (m *Manager) ensureImport(ctx context.Context) error {
	// Get the CoreDNS ConfigMap
	coreDNSConfigMap := &corev1.ConfigMap{}
	coreDNSConfigMapName := types.NamespacedName{
		Name:      m.config.ConfigMapName,
		Namespace: m.config.Namespace,
	}

	if err := m.client.Get(ctx, coreDNSConfigMapName, coreDNSConfigMap); err != nil {
		return fmt.Errorf("failed to get CoreDNS ConfigMap: %w", err)
	}

	// Check if Corefile exists
	corefile, exists := coreDNSConfigMap.Data["Corefile"]
	if !exists {
		return fmt.Errorf("Corefile not found in CoreDNS ConfigMap")
	}

	// Check if import statement already exists
	if strings.Contains(corefile, m.config.ImportStatement) {
		log.Printf("Import statement already exists in CoreDNS Corefile")
		return nil
	}

	// Add import statement after the .:53 { line
	lines := strings.Split(corefile, "\n")
	var newLines []string
	importAdded := false

	for _, line := range lines {
		newLines = append(newLines, line)
		// Add import statement after the main server block starts
		if strings.TrimSpace(line) == ".:53 {" && !importAdded {
			newLines = append(newLines, "    "+m.config.ImportStatement)
			importAdded = true
		}
	}

	if !importAdded {
		log.Printf("Warning: Could not find '.:53 {' in Corefile, appending import statement")
		newLines = append(newLines, m.config.ImportStatement)
	}

	// Update the ConfigMap
	newCorefile := strings.Join(newLines, "\n")
	coreDNSConfigMap.Data["Corefile"] = newCorefile

	if err := m.client.Update(ctx, coreDNSConfigMap); err != nil {
		return fmt.Errorf("failed to update CoreDNS ConfigMap: %w", err)
	}

	log.Printf("Added import statement to CoreDNS Corefile")
	return nil
}

// ensureVolumeMount ensures the CoreDNS deployment has the proper volume mount
func (m *Manager) ensureVolumeMount(ctx context.Context) error {
	// Try to use controller-runtime client first (for testing)
	if m.isFakeClient() {
		controllerClient := &ControllerRuntimeClient{client: m.client}
		return m.ensureVolumeMountWithClient(ctx, controllerClient)
	}

	// For production, we need to use the Kubernetes client
	// This would require the REST config, which we don't have access to here
	// We'll delegate this to the caller or implement it differently
	log.Printf("Volume mount management requires Kubernetes clientset - skipping for now")
	return nil
}

// ensureVolumeMountWithClient ensures volume mount using a deployment client
func (m *Manager) ensureVolumeMountWithClient(ctx context.Context, deploymentClient DeploymentClient) error {
	deployment, err := deploymentClient.GetDeployment(ctx, "coredns", m.config.Namespace)
	if err != nil {
		return fmt.Errorf("failed to get CoreDNS deployment: %w", err)
	}

	modified := false

	// Check if volume already exists
	volumeExists := false
	for _, volume := range deployment.Spec.Template.Spec.Volumes {
		if volume.Name == "custom-config-volume" {
			volumeExists = true
			break
		}
	}

	// Add volume if it doesn't exist
	if !volumeExists {
		newVolume := corev1.Volume{
			Name: "custom-config-volume",
			VolumeSource: corev1.VolumeSource{
				ConfigMap: &corev1.ConfigMapVolumeSource{
					LocalObjectReference: corev1.LocalObjectReference{
						Name: m.config.DynamicConfigMapName,
					},
				},
			},
		}
		deployment.Spec.Template.Spec.Volumes = append(deployment.Spec.Template.Spec.Volumes, newVolume)
		modified = true
	}

	// Check if volume mount exists in CoreDNS container
	for i, container := range deployment.Spec.Template.Spec.Containers {
		if container.Name == "coredns" {
			volumeMountExists := false
			for _, volumeMount := range container.VolumeMounts {
				if volumeMount.Name == "custom-config-volume" {
					volumeMountExists = true
					break
				}
			}

			if !volumeMountExists {
				newVolumeMount := corev1.VolumeMount{
					Name:      "custom-config-volume",
					MountPath: "/etc/coredns/custom",
				}
				deployment.Spec.Template.Spec.Containers[i].VolumeMounts = append(
					deployment.Spec.Template.Spec.Containers[i].VolumeMounts, 
					newVolumeMount,
				)
				modified = true
			}
			break
		}
	}

	if modified {
		if err := deploymentClient.UpdateDeployment(ctx, deployment); err != nil {
			return fmt.Errorf("failed to update CoreDNS deployment: %w", err)
		}
		log.Printf("Updated CoreDNS deployment with custom config volume mount")
	} else {
		log.Printf("CoreDNS deployment already has custom config volume mount")
	}

	return nil
}

// isFakeClient checks if we're using a fake client (for testing)
func (m *Manager) isFakeClient() bool {
	// This is a simplified check - in real implementation you might use reflection
	// or other mechanisms to detect fake clients
	return strings.Contains(fmt.Sprintf("%T", m.client), "fake")
}

// Implementation of DeploymentClient interface

// UpdateDeployment updates a deployment using Kubernetes clientset
func (k *KubernetesClient) UpdateDeployment(ctx context.Context, deployment *appsv1.Deployment) error {
	_, err := k.clientset.AppsV1().Deployments(deployment.Namespace).Update(ctx, deployment, metav1.UpdateOptions{})
	return err
}

// GetDeployment gets a deployment using Kubernetes clientset
func (k *KubernetesClient) GetDeployment(ctx context.Context, name, namespace string) (*appsv1.Deployment, error) {
	return k.clientset.AppsV1().Deployments(namespace).Get(ctx, name, metav1.GetOptions{})
}

// UpdateDeployment updates a deployment using controller-runtime client
func (c *ControllerRuntimeClient) UpdateDeployment(ctx context.Context, deployment *appsv1.Deployment) error {
	return c.client.Update(ctx, deployment)
}

// GetDeployment gets a deployment using controller-runtime client
func (c *ControllerRuntimeClient) GetDeployment(ctx context.Context, name, namespace string) (*appsv1.Deployment, error) {
	deployment := &appsv1.Deployment{}
	key := types.NamespacedName{Name: name, Namespace: namespace}
	err := c.client.Get(ctx, key, deployment)
	return deployment, err
}
