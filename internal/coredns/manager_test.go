package coredns

import (
	"context"
	"strings"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client/fake"
)

func TestNewManager(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	config := Config{
		Namespace:            "kube-system",
		ConfigMapName:        "coredns",
		DynamicConfigMapName: "coredns-ingress-sync-rewrite-rules",
		DynamicConfigKey:     "dynamic.server",
		ImportStatement:      "import /etc/coredns/custom/*.server",
		TargetCNAME:          "ingress.example.com.",
	}

	manager := NewManager(fakeClient, config)
	
	assert.NotNil(t, manager)
	assert.Equal(t, config, manager.config)
}

func TestGenerateDynamicConfig(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	config := Config{
		TargetCNAME: "ingress.example.com.",
	}
	manager := NewManager(fakeClient, config)

	domains := []string{"example.com", "api.example.com"}
	hosts := []string{"app1.example.com", "app2.example.com"}

	result := manager.generateDynamicConfig(domains, hosts)

	// Check that the config contains expected elements
	assert.Contains(t, result, "# Auto-generated by coredns-ingress-sync controller")
	assert.Contains(t, result, "rewrite name exact app1.example.com ingress.example.com.")
	assert.Contains(t, result, "rewrite name exact app2.example.com ingress.example.com.")
	assert.Contains(t, result, time.Now().Format("2006-01-02")) // Should contain today's date
}

func TestUpdateDynamicConfigMap_Create(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))
	
	fakeClient := fake.NewClientBuilder().WithScheme(scheme).Build()
	config := Config{
		Namespace:            "kube-system",
		DynamicConfigMapName: "coredns-ingress-sync-rewrite-rules",
		DynamicConfigKey:     "dynamic.server",
		TargetCNAME:          "ingress.example.com.",
	}
	manager := NewManager(fakeClient, config)

	ctx := context.Background()
	domains := []string{"example.com"}
	hosts := []string{"app1.example.com"}

	err := manager.UpdateDynamicConfigMap(ctx, domains, hosts)
	require.NoError(t, err)

	// Verify ConfigMap was created
	configMap := &corev1.ConfigMap{}
	key := types.NamespacedName{
		Name:      "coredns-ingress-sync-rewrite-rules",
		Namespace: "kube-system",
	}
	err = fakeClient.Get(ctx, key, configMap)
	require.NoError(t, err)

	assert.Equal(t, "coredns-ingress-sync-rewrite-rules", configMap.Name)
	assert.Equal(t, "kube-system", configMap.Namespace)
	assert.Equal(t, "coredns-ingress-sync", configMap.Labels["app.kubernetes.io/managed-by"])
	
	dynamicConfig := configMap.Data["dynamic.server"]
	assert.Contains(t, dynamicConfig, "rewrite name exact app1.example.com ingress.example.com.")
}

func TestUpdateDynamicConfigMap_Update(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))

	// Create existing ConfigMap
	existingConfigMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "coredns-ingress-sync-rewrite-rules",
			Namespace: "kube-system",
		},
		Data: map[string]string{
			"dynamic.server": "# Old content\nrewrite name exact old.example.com ingress.example.com.\n",
		},
	}

	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(existingConfigMap).Build()
	config := Config{
		Namespace:            "kube-system",
		DynamicConfigMapName: "coredns-ingress-sync-rewrite-rules",
		DynamicConfigKey:     "dynamic.server",
		TargetCNAME:          "ingress.example.com.",
	}
	manager := NewManager(fakeClient, config)

	ctx := context.Background()
	domains := []string{"example.com"}
	hosts := []string{"app1.example.com", "app2.example.com"}

	err := manager.UpdateDynamicConfigMap(ctx, domains, hosts)
	require.NoError(t, err)

	// Verify ConfigMap was updated
	configMap := &corev1.ConfigMap{}
	key := types.NamespacedName{
		Name:      "coredns-ingress-sync-rewrite-rules",
		Namespace: "kube-system",
	}
	err = fakeClient.Get(ctx, key, configMap)
	require.NoError(t, err)

	dynamicConfig := configMap.Data["dynamic.server"]
	assert.Contains(t, dynamicConfig, "rewrite name exact app1.example.com ingress.example.com.")
	assert.Contains(t, dynamicConfig, "rewrite name exact app2.example.com ingress.example.com.")
	assert.NotContains(t, dynamicConfig, "old.example.com") // Old content should be replaced
}

func TestUpdateDynamicConfigMap_NoUpdateNeeded(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))

	config := Config{
		Namespace:            "kube-system",
		DynamicConfigMapName: "coredns-ingress-sync-rewrite-rules",
		DynamicConfigKey:     "dynamic.server",
		TargetCNAME:          "ingress.example.com.",
	}
	manager := NewManager(nil, config) // We'll create a fake client with the correct content

	// Generate the expected content
	domains := []string{"example.com"}
	hosts := []string{"app1.example.com"}
	expectedContent := manager.generateDynamicConfig(domains, hosts)

	// Create existing ConfigMap with the same content
	existingConfigMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "coredns-ingress-sync-rewrite-rules",
			Namespace: "kube-system",
		},
		Data: map[string]string{
			"dynamic.server": expectedContent,
		},
	}

	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(existingConfigMap).Build()
	manager.client = fakeClient

	ctx := context.Background()
	err := manager.UpdateDynamicConfigMap(ctx, domains, hosts)
	require.NoError(t, err)

	// ConfigMap should remain unchanged
	configMap := &corev1.ConfigMap{}
	key := types.NamespacedName{
		Name:      "coredns-ingress-sync-rewrite-rules",
		Namespace: "kube-system",
	}
	err = fakeClient.Get(ctx, key, configMap)
	require.NoError(t, err)

	assert.Equal(t, expectedContent, configMap.Data["dynamic.server"])
}

func TestEnsureImport(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))

	// Create CoreDNS ConfigMap without import statement
	coreDNSConfigMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "coredns",
			Namespace: "kube-system",
		},
		Data: map[string]string{
			"Corefile": `.:53 {
    errors
    health {
        lameduck 5s
    }
    ready
    kubernetes cluster.local in-addr.arpa ip6.arpa {
        pods insecure
        fallthrough in-addr.arpa ip6.arpa
        ttl 30
    }
    prometheus :9153
    forward . /etc/resolv.conf
    cache 30
    loop
    reload
    loadbalance
}`,
		},
	}

	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(coreDNSConfigMap).Build()
	config := Config{
		Namespace:       "kube-system",
		ConfigMapName:   "coredns",
		ImportStatement: "import /etc/coredns/custom/*.server",
	}
	manager := NewManager(fakeClient, config)

	ctx := context.Background()
	err := manager.ensureImport(ctx)
	require.NoError(t, err)

	// Verify import statement was added
	updatedConfigMap := &corev1.ConfigMap{}
	key := types.NamespacedName{
		Name:      "coredns",
		Namespace: "kube-system",
	}
	err = fakeClient.Get(ctx, key, updatedConfigMap)
	require.NoError(t, err)

	assert.Contains(t, updatedConfigMap.Data["Corefile"], "import /etc/coredns/custom/*.server")
}

func TestEnsureImport_AlreadyExists(t *testing.T) {
	scheme := runtime.NewScheme()
	require.NoError(t, corev1.AddToScheme(scheme))

	// Create CoreDNS ConfigMap with import statement already present
	coreDNSConfigMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "coredns",
			Namespace: "kube-system",
		},
		Data: map[string]string{
			"Corefile": `.:53 {
    import /etc/coredns/custom/*.server
    errors
    health {
        lameduck 5s
    }
    ready
}`,
		},
	}

	fakeClient := fake.NewClientBuilder().WithScheme(scheme).WithRuntimeObjects(coreDNSConfigMap).Build()
	config := Config{
		Namespace:       "kube-system",
		ConfigMapName:   "coredns",
		ImportStatement: "import /etc/coredns/custom/*.server",
	}
	manager := NewManager(fakeClient, config)

	ctx := context.Background()
	err := manager.ensureImport(ctx)
	require.NoError(t, err)

	// Verify ConfigMap wasn't unnecessarily updated
	configMap := &corev1.ConfigMap{}
	key := types.NamespacedName{
		Name:      "coredns",
		Namespace: "kube-system",
	}
	err = fakeClient.Get(ctx, key, configMap)
	require.NoError(t, err)

	// Should still contain the import statement (and only once)
	corefile := configMap.Data["Corefile"]
	assert.Contains(t, corefile, "import /etc/coredns/custom/*.server")
	
	// Count occurrences - should be exactly 1
	count := strings.Count(corefile, "import /etc/coredns/custom/*.server")
	assert.Equal(t, 1, count, "Import statement should appear exactly once")
}
